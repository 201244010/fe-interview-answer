## Day 13 解答

### html5 中的 form 怎么关闭自动完成？

在 `input` 标签中，可以设置 `autocomplete="off"` 来关闭自动完成。
但这个属性在不同的浏览器上兼容并不好，因此需要配合 `type="newpassword"` 等其他属性来关闭自动完成。  

### ::before 和:after 中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？

`::` 和 `:` 是 CSS3 中为了区别伪类和伪元素所用的不同的写法。`::` 表示伪元素，目前两种写法都被兼容。

`::before`,`::after` 可以在一个 DOM 元素的前面和后面增加一个伪元素。可以用来清除浮动、为元素增加特殊效果（如前面有特殊符号等）。

`::before` 和 `::after` 默认添加的是 `inlne` 元素，通过 `content` 属性来设置展示的内容，并且必须要设置 `content` 属性。`content` 属性可以利用 `attr` 与元素的相关内容做联动。

详细设置和用法可以参考 [css 伪元素:before 和:after 用法详解](https://www.cnblogs.com/wonyun/p/5807191.html)

### 说说你对 javascript 的作用域的理解

在 ES5 之前，javascript 只有函数作用域而没有块级作用域的。即，在 `if` 或者 `for` 花括号中的变量实际在外层是可以被访问的。

```javascript
for (var i = 0; i < 10; i++) {
  var j = 123;
}
console.log(j); // 123;
```

不过使用 ES6 的 `let` 和 `const` 之后，就可以实现块级作用域了。

而函数作用域通过其作用域链的关系，可以实现变量的封装防止污染。子层的函数可以访问父级以及全局的的变量，但反过来则不行。这样子层函数中的变量就与外层隔绝开了。

```javascript
var a = 1;
function b() {
  var b = 2;
  console.log(a);
  function c() {
    // 内部可以访问外部，而外层访问不到内部
    var a = 4;
    var c = 3;
    console.log(a); // 4 不会污染
    console.log(b); // 2
  }
  c();
}

console.log(b());
console.log(a);
```

### http 都有哪些状态码？

- 2xx: 2 开头的状态码表示请求成功。一般以 200 为主。在非简单跨域的请求中会有 `204` `method: OPTIONS` 的预请求来判断服务端是否允许跨域。
- 3xx: 3 开头的与缓存和路径相关
	- 301: 永久重定向，可以认为原地址已经失效
	- 302: 临时重定向，临时跳转到新的地址，可能随时会变化
	- 304: 未修改，让浏览器直接使用之前缓存的资源。（弱缓存或者叫协商缓存）
- 4xx: 4 开头的基本问题出现在前端这里。
	- 400: 服务器不理解请求（一般是参数有错误）
	- 401: 没有权限（没有 token 或者身份认证）
	- 403: 禁止访问（身份通过了但是该身份下没有对应的功能权限）
	- 404: 找不到请求的网页（地址错误）
- 5xx: 5 开头的基本属于服务端错误。
	- 500: 服务器错误
	- 502: 网关错误
	- 503: 服务器目前处于无法使用的状态，一般是临时性的
	- 504: 网关超时